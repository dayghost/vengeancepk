package server.gui;

import java.awt.*;
import java.awt.image.BufferedImage;

/**
 *
 * @author Requiem-Reborn
 */
public class MemoryUsage extends javax.swing.JPanel {

    Runtime rt = Runtime.getRuntime();

    int[] percents = nOneArray(250);
    int pointOffset = 0;

    /** Creates new form MemoryUsage */
    public MemoryUsage() {
        initComponents();
                new Thread(new Runnable(){

            @Override
            public void run(){
                while(true){
                        repaint();
                        try{
                            Thread.sleep(100);
                        }catch(Exception ignored){}
                }
            }
        }).start();
    }



    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 529, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void update(Graphics g){
        paint(g);        
    }

    public int[] nOneArray(int len){
        int[] ret = new int[len];
        for(int i = 0; i < len; i++)
            ret[i] = -1;
        return ret;
    }
    
    BufferedImage memUsageMeter = new BufferedImage(100,95,BufferedImage.TYPE_INT_ARGB);
    BufferedImage memUsageGraph = new BufferedImage(320,170,BufferedImage.TYPE_INT_ARGB);
    BufferedImage statsImg = new BufferedImage(100,100,BufferedImage.TYPE_INT_ARGB);

    @Override
    public void paint(Graphics painter){
        painter.setColor(getBackground());
        painter.fillRect(0,0,getWidth(),getHeight());
        doMemUsageMeter();
        doMemUsageGraph();
        doStats();
        painter.drawImage(memUsageMeter, 5, 5, null);
        painter.drawImage(memUsageGraph,10 + memUsageMeter.getWidth(),5,null);
        painter.drawImage(this.statsImg,5, memUsageMeter.getHeight() + 5, null);
    }

    public void doMemUsageGraph(){
              if(pointOffset >= percents.length - 1){
          for(int i = 1; i < percents.length;i++)
              percents[i - 1] = percents[i];
      }else pointOffset++;

              percents[pointOffset] = getMemUsedPercent();

                Graphics g;
        if(memUsageGraph.getGraphics() == null)
       g = memUsageGraph.createGraphics();
        else g = memUsageGraph.getGraphics();
      g.setColor(Color.BLACK);
      g.fillRect(0, 0, memUsageGraph.getWidth(), memUsageGraph.getHeight());
      g.setColor(Color.DARK_GRAY);
      int w = memUsageGraph.getWidth();
      double xDif = (double)w / (double)percents.length;
      int h = memUsageGraph.getHeight();
      double yDif = (double)h / (double)100;
      for(int x = 0; x <= w; x+=10)
          for(int y = 0; y <= h; y+=10){
              g.drawLine(x,y,x,h);
              g.drawLine(x, y, w, y);
          }
g.setColor(Color.green);
      for(int i = 0; i < percents.length;i++){
        int per = percents[i];
        if(per == -1)
            continue;
        if(i > 0 && i < percents.length - 1){
            if(percents[i - 1] == -1)
                continue;
            g.drawLine((int) ((i - 1) * xDif),h -(int)(percents[i - 1] * yDif),(int)(i * xDif) ,h -(int)(per * yDif));
          }
      }
    }

    public void doMemUsageMeter(){
                Graphics g;
        if(memUsageMeter.getGraphics() == null)
       g = memUsageMeter.createGraphics();
        else g = memUsageMeter.getGraphics();
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, memUsageMeter.getWidth(), memUsageMeter.getHeight());
        g.setColor(Color.GREEN);
        g.drawRect(5, 5, 90, 70);

        int barCount = getMemUsedPercent() / 10;
        for(int i = 1; i <= barCount;i++){
        g.fillRect(15, 70 - (6 * i), 70, 5);
        }
        g.setFont(new Font(g.getFont().getName(),Font.PLAIN,10));
        g.drawString("Mem Used:" + getMemUsedPercent() + "%",  10 , 90);
    }

    private int getMemUsedPercent() {
        long memUsed = rt.totalMemory() - rt.freeMemory();
        return (int)((memUsed * 100) / rt.totalMemory());
    }

    private void doStats() {
        Graphics g;
        if((g = statsImg.getGraphics()) == null)
            g = statsImg.createGraphics();
        g.setColor(this.getBackground());
        g.fillRect(0, 0, statsImg.getWidth(), statsImg.getHeight());
        g.setColor(Color.black);
        g.drawString("Used:" + getMemUsed() + "MB",0,20);
        g.drawString("Free:" + getFreeMem()+ "MB", 0, 40);
        g.drawString("Total:" + getTotalMem() + "MB", 0,60);
    }

    public double getTotalMem(){
         double ret = (double)(rt.totalMemory() / 1024) / 1024.0;
        return (Math.round(ret  * 100)) / 100.0;
    }

        public double getFreeMem(){
        double ret = (double)(rt.freeMemory() / 1024) / 1024.0;
        return (Math.round(ret  * 100)) / 100.0;
    }

    public double getMemUsed(){
        long free = rt.freeMemory();
        long total = rt.totalMemory();
        long used = total - free;

        double ret = ((double)used / 1024.0) / 1024.0;
        return (Math.round(ret  * 100.0)) / 100.0;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

}
